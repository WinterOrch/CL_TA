#### ProjectMain

代表进程（节点），每一个银行启动一个ProjectMain线程。

ProjectMain中State为枚举类型，其中SNAPPING代表执行快照的状态，WORKING代表普通状态，即没执行快照时的状态。

 

包括了：

CurrentID：代表当前节点是第几个节点

numOfNodes：代表系统中所有银行的个数

CurrentNode：当前节点在NodesInSystem这个ArrayList排第几个

NodesInSystem：系统中所有节点

AdjMatrix：邻接矩阵，相应位置代表是否有邻居



NodesMapInSystem：从邻接矩阵中判断有几个节点是当前的邻居节点，将这些节点保存在NodesMapInSystem中。Interger代表邻居节点的序号，Node代表节点本身，即银行。

Channels：根据NodeSMapInSystem中的邻居节点，生成对应的socket，将这些socket存放在channels中。Channels中的Interger与NodesMapInSystem对应。

OutputStreamHashMap：也是一个HashMap类型，其中每一个outputstream对应于channels当中的一个socket。

WaitingBuffer：HashMap类型，其中key为Interger，与channels、NodesMapInSystem中的Interger一样，代表当前节点的序号；concurrentLinkedQueue\<ApplicationMsg>为一个队列，该队列中的元素所要发送的消息，其本质为一个消息队列，当state为SNAPPING，waitingBuffer中的消息阻塞，不发送出去，当state为WORKING时，消息立刻发送。

过程：当前节点（银行系统）通过邻接矩阵判断自己与哪些节点相邻，然后生成与邻居相对应的套接字，有几个邻居就有几个套接字，套接字

 

首先说明的是，节点间传送的消息都是String类型

Message，是所有消息的一个基类。

ApplicationMsg：是正常的业务消息，继承Message。

MarkerMsg是你们要实现的一个类，也继承了Message，这里面具体细节由你们自己定义

 

#### Cache

继承了HashMap<String，Interger>，其中String代表当前银行中存放的账户，例如,A代表A账户，B代表B账户，C代表C账户，我们这个系统里，假设每个银行总共有三个账户，Interger代表对应账户的金额。

其中，Cache（）构造函数完成了三个账户的初始化，CACHE_INITIALIZED_SIZE为初始化金额，我们定义为2000、

Put（）完成账户的添加、修改

Get（）获取key对应账户的数额

Transfer（）完成转账的动作

Receive（）完成收账的动作



#### Thread

ClientThread：该线程负责监听邻居节点发来的消息，并针对消息的类型（Application或者MarkerMsg）具体处理

EmitMessageThread：负责发送消息。

ChandyLamportThread：该线程也是你们需要实现的部分，配合makerMsg使用